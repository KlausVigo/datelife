#                                        labels=c("10" = "1",
#                                                 "100" = expression(10^2),
#                                                 "200" = expression(2*"x"*10^2),
#                                                 "300" = expression(3*"x"*10^2),
#                                                 "400" = expression(4*"x"*10^2),
#                                                 "500" = expression(5*"x"*10^2),
#                                                 "700" = expression(7*"x"*10^2),
#                                                 "1000" = expression(10^3),
#                                                 "1500" = expression(1.5*"x"*10^3),
#                                                 "2000" = expression(2*"x"*10^3),
#                                                 "3000" = expression(3*"x"*10^3),
#                                                 "4000" = expression(4*"x"*10^3),
#                                                 "5000" = expression(5*"x"*10^3),
#                                                 "6000" = expression(6*"x"*10^3),
#                                                 "7000" = expression(7*"x"*10^3),
#                                                 "8000" = expression(8*"x"*10^3),
#                                                 "9000" = expression(9*"x"*10^3),
#                                                 "10000" = expression(10^4),
#                                                 "12750" = expression(1.275*"x"*10^4)
#                                        )
# )
plt <- plt + ggplot2::scale_x_discrete(name = "Query Length",
labels=c("10" = "10",
"100" = "100",
"200" = "200",
"300" = "300",
"400" = "400",
"500" = "500",
"700" = "700",
"1000" = expression(1~0*0*0),
"1500" = expression(1~500),
"2000" = expression(2~0*0*0),
"3000" = expression(3~0*0*0),
"4000" = expression(4~0*0*0),
"5000" = expression(5~0*0*0),
"6000" = expression(6~0*0*0),
"7000" = expression(7~0*0*0),
"8000" = expression(8~0*0*0),
"9000" = expression(9~0*0*0),
"10000" = expression(10~0*0*0),
"12750" = expression(12~750)
)
)
plt <- plt + ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45, hjust=1))
plt <- plt + ggplot2::theme(axis.text.y = ggplot2::element_text(angle=0))
plt <- 	plt + ggplot2::scale_y_log10(name="Time (seconds)", breaks=c(1e+03, 1e+04, 3e+04, 1e+05),
labels=c("1e+03"="1 s", "1e+04"="10 s", "3e+04"="30 s", "1e+05"="100 s"),
position="left",
sec.axis = ggplot2::sec_axis(~ . *1, name="Time (minutes)",
breaks=c(6e+03, 3e+04, 6e+04, 9e+04),
labels=c("6e+03"="0.1 min", "3e+04"="0.5 min", "6e+04"="1 min", "9e+04"="1.5 min")
)
)
plt
dev.off()
ggplot2::autoplot(res)
setwd("~/Google Drive/datelife/runtime_tests/2_tests/2_random_spp_names/2_make_datelife_query")
ninput <- c(10,100,200,300,400,500,700,1000,1500,2000,3000,4000, 5000, 6000,7000,8000,9000,10000)
length(ninput)
res <- c()
for(i in ninput){
x <- paste0("processinput_runtime_2018.01.11_",i,"_aves_spp")
xname <- paste0("make_datelife_query_runtime_2018.01.11_",i,"_aves_spp.RData")
load(xname)
res <- rbind(res, get(x))
}
length(res)
str(res)
processinput_runtime_2018.01.11_12750_aves_spp
res <- rbind(res, processinput_runtime_2018.01.11_12750_aves_spp)
ggplot2::autoplot(res)
ggplot2::autoplot(res)
res
str(res)
processinput_runtime_2018.01.11_12750_aves_spp
ggplot2::autoplot(res)
y_min <- 200
y_max <- 1e+5
res$Time <- microbenchmark:::convert_to_unit(res$time, "t") #changing the name of the element itself is the easiest way to make it appear as axis label
# object$'Query Length' <- object$expr #changing for a name with spaces won't work...
plt <- ggplot2::ggplot(res, ggplot2::aes_string(x = "expr", y = "Time"))
plt <- plt + ggplot2::coord_cartesian(ylim = c(y_min, y_max))
plt <- plt + ggplot2::stat_ydensity()
# plt <- plt + ggplot2::scale_x_discrete(name = "Query Length (log10)",
#                                        labels=c("10" = "1",
#                                                 "100" = expression(10^2),
#                                                 "200" = expression(2*"x"*10^2),
#                                                 "300" = expression(3*"x"*10^2),
#                                                 "400" = expression(4*"x"*10^2),
#                                                 "500" = expression(5*"x"*10^2),
#                                                 "700" = expression(7*"x"*10^2),
#                                                 "1000" = expression(10^3),
#                                                 "1500" = expression(1.5*"x"*10^3),
#                                                 "2000" = expression(2*"x"*10^3),
#                                                 "3000" = expression(3*"x"*10^3),
#                                                 "4000" = expression(4*"x"*10^3),
#                                                 "5000" = expression(5*"x"*10^3),
#                                                 "6000" = expression(6*"x"*10^3),
#                                                 "7000" = expression(7*"x"*10^3),
#                                                 "8000" = expression(8*"x"*10^3),
#                                                 "9000" = expression(9*"x"*10^3),
#                                                 "10000" = expression(10^4),
#                                                 "12750" = expression(1.275*"x"*10^4)
#                                        )
# )
plt <- plt + ggplot2::scale_x_discrete(name = "Query Length",
labels=c("10" = "10",
"100" = "100",
"200" = "200",
"300" = "300",
"400" = "400",
"500" = "500",
"700" = "700",
"1000" = expression(1~0*0*0),
"1500" = expression(1~500),
"2000" = expression(2~0*0*0),
"3000" = expression(3~0*0*0),
"4000" = expression(4~0*0*0),
"5000" = expression(5~0*0*0),
"6000" = expression(6~0*0*0),
"7000" = expression(7~0*0*0),
"8000" = expression(8~0*0*0),
"9000" = expression(9~0*0*0),
"10000" = expression(10~0*0*0),
"12750" = expression(12~750)
)
)
plt <- plt + ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45, hjust=1))
plt <- plt + ggplot2::theme(axis.text.y = ggplot2::element_text(angle=0))
plt <- 	plt + ggplot2::scale_y_log10(name="Time (seconds)", breaks=c(1e+03, 1e+04, 3e+04, 1e+05),
labels=c("1e+03"="1 s", "1e+04"="10 s", "3e+04"="30 s", "1e+05"="100 s"),
position="left",
sec.axis = ggplot2::sec_axis(~ . *1, name="Time (minutes)",
breaks=c(6e+03, 3e+04, 6e+04, 9e+04),
labels=c("6e+03"="0.1 min", "3e+04"="0.5 min", "6e+04"="1 min", "9e+04"="1.5 min")
)
)
plt
dev.off()
pdf(file="make_datelife_query_microbenchmark_2018.01.11_xtime_good_labels.pdf", width = 5, height = 3)
y_min <- 200
y_max <- 1e+5
res$Time <- microbenchmark:::convert_to_unit(res$time, "t") #changing the name of the element itself is the easiest way to make it appear as axis label
# object$'Query Length' <- object$expr #changing for a name with spaces won't work...
plt <- ggplot2::ggplot(res, ggplot2::aes_string(x = "expr", y = "Time"))
plt <- plt + ggplot2::coord_cartesian(ylim = c(y_min, y_max))
plt <- plt + ggplot2::stat_ydensity()
# plt <- plt + ggplot2::scale_x_discrete(name = "Query Length (log10)",
#                                        labels=c("10" = "1",
#                                                 "100" = expression(10^2),
#                                                 "200" = expression(2*"x"*10^2),
#                                                 "300" = expression(3*"x"*10^2),
#                                                 "400" = expression(4*"x"*10^2),
#                                                 "500" = expression(5*"x"*10^2),
#                                                 "700" = expression(7*"x"*10^2),
#                                                 "1000" = expression(10^3),
#                                                 "1500" = expression(1.5*"x"*10^3),
#                                                 "2000" = expression(2*"x"*10^3),
#                                                 "3000" = expression(3*"x"*10^3),
#                                                 "4000" = expression(4*"x"*10^3),
#                                                 "5000" = expression(5*"x"*10^3),
#                                                 "6000" = expression(6*"x"*10^3),
#                                                 "7000" = expression(7*"x"*10^3),
#                                                 "8000" = expression(8*"x"*10^3),
#                                                 "9000" = expression(9*"x"*10^3),
#                                                 "10000" = expression(10^4),
#                                                 "12750" = expression(1.275*"x"*10^4)
#                                        )
# )
plt <- plt + ggplot2::scale_x_discrete(name = "Query Length",
labels=c("10" = "10",
"100" = "100",
"200" = "200",
"300" = "300",
"400" = "400",
"500" = "500",
"700" = "700",
"1000" = expression(1~0*0*0),
"1500" = expression(1~500),
"2000" = expression(2~0*0*0),
"3000" = expression(3~0*0*0),
"4000" = expression(4~0*0*0),
"5000" = expression(5~0*0*0),
"6000" = expression(6~0*0*0),
"7000" = expression(7~0*0*0),
"8000" = expression(8~0*0*0),
"9000" = expression(9~0*0*0),
"10000" = expression(10~0*0*0),
"12750" = expression(12~750)
)
)
plt <- plt + ggplot2::theme(axis.text.x = ggplot2::element_text(angle=45, hjust=1))
plt <- plt + ggplot2::theme(axis.text.y = ggplot2::element_text(angle=0))
plt <- 	plt + ggplot2::scale_y_log10(name="Time (seconds)", breaks=c(1e+03, 1e+04, 3e+04, 1e+05),
labels=c("1e+03"="1 s", "1e+04"="10 s", "3e+04"="30 s", "1e+05"="100 s"),
position="left",
sec.axis = ggplot2::sec_axis(~ . *1, name="Time (minutes)",
breaks=c(6e+03, 3e+04, 6e+04, 9e+04),
labels=c("6e+03"="0.1 min", "3e+04"="0.5 min", "6e+04"="1 min", "9e+04"="1.5 min")
)
)
plt
dev.off()
get_datelife_result(input = "thraupidae")
get_datelife_result(input = "thraupidae", get_spp_from_taxon = TRUE)
thrau_spp <- make_datelife_query(input = "thraupidae", get_spp_from_taxon = TRUE)
str(thrau_spp)
thrau_spp <- thrau_spp$cleaned_names
length(thrau_spp)
thrau_gdr_2018.03.13 <- get_datelife_result(input = "thraupidae", get_spp_from_taxon = TRUE)
thrau_gdr <- get_datelife_result(input = "thraupidae", get_spp_from_taxon = TRUE)
save(thrau_gdr, file = "/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_gdr_2018.03.13.RData")
save(thrau_spp, file = "/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_spp_2018.03.13.RData")
length(thrau_gdr)
thrau_sdm <- datelife_result_sdm(thrau_gdr)
devtools::load_all(pkg = "~/Desktop/datelife")
thrau_sdm <- datelife_result_sdm(thrau_gdr)
load(file = "/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_sdm_2018.03.14.RData")
plot(thrau_sdm$phy_sdm)
thrau_sdm$phy_sdm
thrau_sdm
str(thrau_sdm)
ls(thrau_sdm)
thrau_sdm$phy_sdm
datelife_result <- thrau_gdr
load(file = "/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_SDM.result_2018.03.14.RData")
load(file = "/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_SDM.result_2018.03.14.RData")
ls(thrau_SDM.result)
class(thrau_SDM.result)
thrau_SDM.result
ncol(thrau_SDM.result)
nrow(thrau_SDM.result)  # of 383 col
thrau_SDM.result[,1]
thrau_SDM.result[,1:2]
patristic_matrix_to_phylo(thrau_SDM.result)
ape::njs(thrau_SDM.result)
anyNA(thrau_SDM.result)
patristic_matrix <- thrau_SDM.result
patristic_matrix <- patristic_matrix[rowSums(is.na(patristic_matrix)) != ncol(patristic_matrix),colSums(is.na(patristic_matrix)) != nrow(patristic_matrix)]
patristic_matrix[,382:383]
is.na(patristic_matrix)
is.na(patristic_matrix[,382:383])
rowSums(is.na(patristic_matrix))
ncol(patristic_matrix)
rowSums(is.na(patristic_matrix)) != ncol(patristic_matrix)
colSums(is.na(patristic_matrix))
is.na(patristic_matrix)
rowSums(is.na(patristic_matrix))
patristic_matrix_to_phylo <- function(patristic_matrix) {
if(anyNA(patristic_matrix)) {
patristic_matrix <- patristic_matrix[rowSums(is.na(patristic_matrix)) != ncol(patristic_matrix),colSums(is.na(patristic_matrix)) != nrow(patristic_matrix)]
}   # I'm not sure why this is here. It does not get rid of spp with NA or NaNs
if(dim(patristic_matrix)[1] < 2) {
return(NA)
}
tree <- NA
if(dim(patristic_matrix)[1] == 2) {
tree <- ape::rtree(n = 2, rooted = TRUE, tip.label = rownames(patristic_matrix), br = patristic_matrix[1,2]/2)
} else {
if(anyNA(patristic_matrix)){
tree <- ape::njs(patristic_matrix)  # when there are missing values, nj does not work
} else {
tree <- ape::nj(patristic_matrix)
}
}
if(ape::Ntip(tree) > 2) {
tree <- phangorn::midpoint(tree)
}
if(length(which(tree$edge.length < 0)) > 0) {
warning(paste("Converting from patristic distance matrix to a tree resulted in some negative branch lengths; the largest by magnitude was", min(tree$edge.length)))
# tree$edge.length[which(tree$edge.length < 0)] <- 0 #sometimes NJ returns tiny negative branch lengths. https://github.com/phylotastic/datelife/issues/11
tree <- tree_fix_brlen(tree = tree, fixing_criterion = "negative", fixing_method = 0)
}
return(tree)
}
patristic_matrix_to_phylo(thrau_SDM.result)
thrau_try <- patristic_matrix_to_phylo(thrau_SDM.result)
plot(thrau_try)
thrau_sdm_try <- patristic_matrix_to_phylo(thrau_SDM.result)
pdf(file ="/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_sdm_try.pdf", width = 15, height = 30)
plot(thrau_sdm_try, cex=0.1)
dev.off()
pdf(file ="/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_sdm_try.pdf", width = 15, height = 30)
plot(thrau_sdm_try, cex=0.5, label.offset = 1)
dev.off()
is.ultrametric(thrau_sdm_try)
ape::is.ultrametric(thrau_sdm_try)
library(rphylotastic)
taxon_get_species("thraupidae") # works, 382 spp, how many recognized spp?
length(taxon_get_species("thraupidae")# works, 382 spp, how many recognized spp?
x <- EstimateDates("thraupidae", sppfromtaxon= TRUE) # 11 chronograms
for(i in 1:length(x)){
plot(x[[i]])
ape::axisPhylo()
}
# crown node age range is very large:
x.bt <- c()
for(i in 1:length(x)){
x.bt <- c(x.bt, max(branching.times(x[[i]])))
}
x.bt
# [1] 50.144104 50.000000 16.830590 14.333651 19.301977 21.514088  0.905500 14.338404 83.702729 44.295860  3.256786
taxon_get_species("chiroptera") # Error in open.connection(con, "rb") : HTTP error 403.
taxon_get_species("pteropodidae") # 205 spp
x <- EstimateDates("pteropodidae", sppfromtaxon= TRUE) # 4 chronograms
for(i in 1:length(x)){
plot(x[[i]])
ape::axisPhylo()
}
taxon_get_species("metatheria") # Error in open.connection(con, "rb") : HTTP error 403.
length(taxon_get_species("thraupidae"))# works, 382 spp, how many recognized spp?
sphen_spp <- make_datelife_query(input = "spheniscidae", get_spp_from_taxon = TRUE)
str(sphen_spp)
sphen_spp <- sphen_spp$cleaned_names
length(sphen_spp) # 532 spp, it was 382 in october, hmmmm
save(sphen_spp, file = "/Users/luna/Google Drive/datelife/dating_otol/2_spheniscidae/thrau_spp_2018.03.14.RData")
sphen_gdr <- get_datelife_result(input = "spheniscidae", get_spp_from_taxon = TRUE)
save(sphen_gdr, file = "/Users/luna/Google Drive/datelife/dating_otol/2_spheniscidae/sphen_gdr_2018.03.14.RData")
devtools::load_all(pkg = "~/Desktop/datelife")
sphen_sdm <- datelife_result_sdm(sphen_gdr)
save(sphen_sdm, file = "/Users/luna/Google Drive/datelife/dating_otol/2_spheniscidae/sphen_sdm_2018.03.14.RData")
plot(sphen_sdm$phy, cex=0.5, label.offset = 1)
load(file = "/Users/luna/Google Drive/datelife/dating_otol/1_thraupidae/thrau_SDM_all_2018.03.14.RData")
str(thrau_SDM_all)
ls(thrau_SDM_all)
names(thrau_SDM_all)
class(thrau_SDM_all)
length(thrau_SDM_all)
thrau_SDM_all[[2]]
thrau_SDM_all[[2]][,382:383]
felid_spp <- make_datelife_query(input = "felidae", get_spp_from_taxon = TRUE)
str(felid_spp)
felid_spp <- felid_spp$cleaned_names
length(felid_spp) # still 84 spp
felid_gdr <- get_datelife_result(input = "felidae", get_spp_from_taxon = TRUE)
save(felid_gdr, file = "/Users/luna/Google Drive/datelife/dating_otol/3_felidae/felid_gdr_2018.03.14.RData")
felid_spp <- make_datelife_query(input = "felidae", get_spp_from_taxon = TRUE)
str(felid_spp)
felid_spp <- felid_spp$cleaned_names
length(felid_spp) # still 99 spp
save(felid_spp, file = "/Users/luna/Google Drive/datelife/dating_otol/3_felidae/felid_spp_2018.03.14.RData")
felid_sdm <- datelife_result_sdm(felid_gdr)
save(felid_sdm, file = "/Users/luna/Google Drive/datelife/dating_otol/3_felidae/felid_sdm_2018.03.14.RData")
plot(felid_sdm$phy, cex=0.5, label.offset = 1)
felid_phylo_median <- summarize_datelife_result(felid_gdr, summary_format = "phylo.median")
data(strat2012, package = "phyloch")
plot(phy, cex=0.5, label.offset = 1)  # not ultrametric, try upgma
pdf(file ="/Users/luna/Google Drive/datelife/dating_otol/3_felidae/felid_sdm.pdf", width = 15, height = 30)
plot(felid_sdm$phy, cex=0.5, label.offset = 1)  # not ultrametric, try upgma
dev.off()
data(strat2012, package = "phyloch")
pdf(file ="/Users/luna/Google Drive/datelife/dating_otol/3_felidae/felid_sdm.pdf")
plot(felid_sdm$phy, cex=0.5, label.offset = 1)  # not ultrametric, try upgma
dev.off()
pdf(file ="/Users/luna/Google Drive/datelife/dating_otol/3_felidae/felid_phylo_median.pdf")
plot(felid_phylo_median, cex=0.5, label.offset = 0.5)  # not ultrametric, try upgma
phyloch::axisGeo(GTS = strat2012, cex = 0.5)
dev.off()
library(knitr)
render(input = "~/Users/luna/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
library(rmarkdown)
render(input = "~/Users/luna/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
render(input = "~/Desktop/datelife_paper1/Datelife_paper1.md", output_format = "pdf_document")
str(felid_gdr)
felid_gdr_phylo.all <- summarize_datelife_result(felid_gdr, add_taxon_distribution = "summary", summary_format = "phylo.all")
names(felid_gdr_phylo.all)
felid_gdr_phylo.all$absent.taxa
felid_gdr_phylo.all$taxon_distribution
felid_spp
getwd()
devtools::load_all(pkg = "~/Desktop/datelife")
input = c("Rhea americana",  "Struthio camelus", "Gallus gallus")
datelife_query_check(datelife_query = input)
phy.pars <- make_bold_otol_tree(input=c("Rhea americana",  "Struthio camelus","Gallus gallus", "Pterocnemia pennata"), marker="COI", otol_version="v2", doML=FALSE)
phy.ml <- make_bold_otol_tree(input=c("Rhea americana",  "Struthio camelus","Gallus gallus", "Pterocnemia pennata"), marker="COI", otol_version="v2", doML=TRUE)
use_tnrs = FALSE
approximate_match = TRUE
marker = "COI"
otol_version = "v2"
chronogram = TRUE
doML = FALSE
get_spp_from_taxon = FALSE
verbose = FALSE
input <- datelife_query_check(datelife_query = input, use_tnrs = use_tnrs, approximate_match = approximate_match, get_spp_from_taxon = get_spp_from_taxon, verbose = verbose)
input <- input$cleaned_names
xx <- seq(1, length(input), 250)
yy <- xx+249
yy[length(xx)] <- length(input)
# if(length(input)%%250 != 0) {
# 	yy[length(xx)] <- length(input)
# }
sequences <- c()
for (i in seq_len(length(xx))){
sequences <- rbind(sequences, bold::bold_seqspec(taxon = input[xx[i]:yy[i]], marker = marker)) # bold::bold_seqspec function only allows searches of up to 335 names, ater that, it gives following Error: Request-URI Too Long (HTTP 414)
}
if(length(sequences) == 1) {  # it is length == 80 when there is at least 1 sequence available; if this is TRUE, it means there are no sequences in BOLD for the set of input taxa.
if (verbose) cat("No sequences found in BOLD for input taxa...", "\n")
# if (!use_tnrs) cat("Setting use_tnrs = TRUE might change this, but it can be slowish.", "\n")
warning("Names in input do not match BOLD specimen records. No tree was constructed.")
return(NA)
}
sequences$nucleotide_ATGC <- gsub("[^A,T,G,C]", "", sequences$nucleotides)  # preserve good nucleotide data, i.e., only A,T,G,C
sequences$nucleotide_ATGC_length <- unlist(lapply(sequences$nucleotide_ATGC, nchar))  # add a column in data.frame, indicating the amount of good information contained in sequences#nucelotides (ATGC)
if (verbose) cat("\t", "OK.", "\n")
rr <- c()
for (i in seq_len(length(xx))){
rr <- rbind(rr, suppressWarnings(rotl::tnrs_match_names(names = input[xx[i]:yy[i]])))
}
rr <- rr[!is.na(rr$unique_name),]  # gets rid of names not matched with rotl::tnrs_match_names; otherwise rotl::tol_induced_subtree won't run
phy <- ape::multi2di(rotl::tol_induced_subtree(ott_ids = rr$ott_id, label_format = "name",  otl_v = otol_version))
phy$tip.label <- gsub(".*_ott","", phy$tip.label)  # leaves only the ott_id as tip.label, it's safer than matching by name
# when there are synonyms among the input names, phy will conserve the accepted name (rr$uniqe_name) instead of the original query name from input (rr$search_string)
# this produces an error downstream, while using phangorn::pml()
# to avoid this error, we replace the unique name by the original query name in phy$tip.label:
mm <- match(phy$tip.label, gsub(" ","_", rr$ott_id))  # this gets the order of tip labels in phy
phy$tip.label <- gsub(" ","_", input[mm])  # this overlaps the original query over phy$tip.labels in the correct order
final.sequences <- matrix("-", nrow = length(input), ncol = max(sapply(strsplit(sequences$nucleotides, ""), length)))
final.sequences.names <- rep(NA, length(input))
row.index <- 0
taxa.to.drop <- c()
for (i in input){
row.index <- row.index + 1
taxon.index <- which(grepl(i, sequences$species_name))
# if there are no sequences from any taxon, taxon.index is empty
# but we make sure this is filtered steps before
if (length(taxon.index) > 0){
seq.index <- which.max(sequences$nucleotide_ATGC_length[taxon.index])
# sequences[taxon.index,][seq.index,]
seq <- strsplit(sequences$nucleotides[taxon.index][seq.index], split = "")[[1]]
final.sequences[row.index, sequence(length(seq))] <- seq
} else {
taxa.to.drop <- c(taxa.to.drop, i)
}
final.sequences.names[row.index] <- i
}
rownames(final.sequences) <- gsub(" ", "_", final.sequences.names)
if(length(input)-length(taxa.to.drop) == 1) {
if (verbose) cat("BOLD sequences found only for one input name", input[which(!input %in% taxa.to.drop)], "...","\n","\t", "Cannot construct a tree." )
warning("Not enough sequences available in BOLD. No tree was constructed.")
# if (use_tnrs == FALSE) cat("Setting use_tnrs = TRUE might change this, but it is time consuming.", "\n")
return(NA)
}
if(length(taxa.to.drop) > 0) {
if (verbose) {
taxa.to.drop.print <- paste(taxa.to.drop, collapse = " | ")
cat("No", marker, "sequences found for", taxa.to.drop.print, "...", "\n", "\t", "Dropping taxa from tree.", "\n")
}
#warning("No ", marker, " sequences found for ", taxa.to.drop.print, "...", "\n", "\t", "Taxa dropped from tree.")
taxa.to.drop <- gsub(" ", "_", taxa.to.drop)
phy <- ape::drop.tip(phy, taxa.to.drop)
}
if (verbose) {
cat("Aligning with MAFFT...", "\n")
}
alignment <- ape::as.DNAbin(final.sequences)
alignment <- phangorn::as.phyDat(ips::mafft(alignment))
if (verbose) {
cat( "\t", "OK.", "\n", "Estimating BOLD-OToL tree...", "\n")
}
pml.object <- phangorn::pml(phangorn::acctran(phy, alignment), data = alignment)
phy <- pml.object$tree
if(!ape::is.binary.tree(pml.object$tree)){
if (verbose) {
cat("\t", marker, " sequence data available generates a non-dichotomous tree...", "\n", "\t", "Resolving with multi2di...", "\n")
}
pml.object$tree <- ape::multi2di(pml.object$tree)
phy <- pml.object$tree
}
if (verbose) {
cat("\t", "OK.", "\n")
}
if (chronogram) {
if (verbose) {
cat("Dating BOLD-OToL tree with chronoMPL...", "\n")
}
pml.object$tree <- ape::chronoMPL(pml.object$tree, se = FALSE, test = FALSE)
phy <- pml.object$tree
if (verbose) cat("\t", "OK.", "\n")
}
if(any(pml.object$tree$edge.length < 0)) {
warning("\t", "Negative branch lengths in BOLD chronogram.", "\n")
if(doML) warning("\t", "\t", "Cannot do ML branch length optimization.", "\n")
} else {
if(doML) {
phy <- phangorn::optim.pml(pml.object, data = alignment, rearrangement = "none", optRooted = TRUE, optQ = TRUE)$tree
}
}
phy$tip.label <- gsub('_', ' ', phy$tip.label)
if (verbose) {
cat("Done.", "\n")
}
phy.pars <- make_bold_otol_tree(input=c("Rhea americana",  "Struthio camelus","Gallus gallus", "Pterocnemia pennata"), marker="COI", otol_version="v2", doML=FALSE)
