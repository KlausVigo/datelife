plot(x4)
asd <- "((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);"
x4 <- make_bold_otol_tree(asd)
plot(x4)
x5 <- FixNegBrLen(x4, method="zero")
plot(x5)
tree <- asd.gbot
index <- which(tree$edge.length<0)
index
tree <- x4
tree
index <- which(tree$edge.length<0)
index
cnode <- tree$edge[i,2]
cnode
i=index
cnode <- tree$edge[i,2]
cnode
dauedge <- which(tree$edge[,1]==cnode)
dauedge
pos.tree <- ProcessPhy(tree)
plot(pos.tree)
pos.tree$edge.length[dauedge]
tree$edge.length[i]
FixNegBrLen <- function(tree, method = "zero"){#
	pos.tree <- ProcessPhy(tree)#
	plot(pos.tree)#
	if(class(pos.tree)!="phylo") stop("tree must be a newick character string or in phylo format")#
	if(is.null(pos.tree$edge.length)) stop("tree must have branch lengths")#
	if(!is.ultrametric(pos.tree)) stop("branch lengths must be relative to time")#
	method <- match.arg(method, c("zero", "bladj", "bd"))#
	index <- which(tree$edge.length<0)#
	if(method=="zero") {# chunck for neg br len to zero#
		for (i in index){#
			snode <- tree$edge[i,1]#
			pool  <- tree$edge[seq(nrow(tree$edge))[-i], 1]#
			sisedge <- which(pool==snode) # determines position of sister edge#
			pos.tree$edge.length[sisedge] <- tree$edge.length[sisedge] - tree$edge.length[i] # adds neg branch length to sister branch, should add error to both sides???? or only to the daughter branches??#
			# cnode <- tree$edge[i,2]#
			# dauedge <- which(tree$edge[,1]==cnode)#
			# pos.tree$edge.length[dauedge] <- tree$edge.length[dauedge] + tree$edge.length[i]#
			# pos.tree$edge.length[i] <- 0#
		}#
	}#
	if(method=="bladj"){#chunck for bladj#
		treenl <- paste("n", seq(tree$Nnode), sep="")#
		tree$node.label <- treenl#
		treebt <- ape::branching.times(tree)#
		cnode <- tree$edge[index,2]#
		tobladj <- cnode-tree$Nnode-1#
		nn <- treenl[-tobladj]#
		na <- treebt[-tobladj]#
		attributes(na) <- NULL#
		pos.tree <- GetBladjTree(nodenames = nn, nodeages = na, tree = tree, treeformat = "phylo")#
		# plot(pos.tree)#
	}#
	# if(method=="bd")# chunck for bd tree#
	#GetBdTree function#
	return(pos.tree)#
}
x5 <- FixNegBrLen(x4, method="zero")
plot(x5)
tree$edge.length
dauedge
pos.tree$edge.length[dauedge]
plot(tree)
plot(pos.tree)
pos.tree$edge.length
tree$edge
pos.tree$edge
FixNegBrLen <- function(tree, method = "zero"){#
	pos.tree <- ProcessPhy(tree)#
	plot(pos.tree)#
	if(class(pos.tree)!="phylo") stop("tree must be a newick character string or in phylo format")#
	if(is.null(pos.tree$edge.length)) stop("tree must have branch lengths")#
	if(!is.ultrametric(pos.tree)) stop("branch lengths must be relative to time")#
	method <- match.arg(method, c("zero", "bladj", "bd"))#
	index <- which(pos.tree$edge.length<0)#
	if(method=="zero") {# chunck for neg br len to zero#
		for (i in index){#
			# snode <- pos.tree$edge[i,1]#
			# pool  <- pos.tree$edge[seq(nrow(pos.tree$edge))[-i], 1]#
			# sisedge <- which(pool==snode) # determines position of sister edge#
			# pos.tree$edge.length[sisedge] <- pos.tree$edge.length[sisedge] - pos.tree$edge.length[i] # adds neg branch length to sister branch, should add error to both sides???? or only to the daughter branches??#
			cnode <- pos.tree$edge[i,2]#
			dauedge <- which(pos.tree$edge[,1]==cnode)#
			pos.tree$edge.length[dauedge] <- pos.tree$edge.length[dauedge] + pos.tree$edge.length[i]#
			pos.tree$edge.length[i] <- 0#
		}#
	}#
	if(method=="bladj"){#chunck for bladj#
		treenl <- paste("n", seq(tree$Nnode), sep="")#
		tree$node.label <- treenl#
		treebt <- ape::branching.times(tree)#
		cnode <- tree$edge[index,2]#
		tobladj <- cnode-tree$Nnode-1#
		nn <- treenl[-tobladj]#
		na <- treebt[-tobladj]#
		attributes(na) <- NULL#
		pos.tree <- GetBladjTree(nodenames = nn, nodeages = na, tree = tree, treeformat = "phylo")#
		# plot(pos.tree)#
	}#
	# if(method=="bd")# chunck for bd tree#
	#GetBdTree function#
	return(pos.tree)#
}
x5 <- FixNegBrLen(x4, method="zero")
plot(x5)
ape::axisPhylo()
x6 <- FixNegBrLen(x4, method="bladj")
GetBladjTree <- function(nodenames, nodeages, tree, treeformat="newick"){#
	treeformat <- match.arg(treeformat, choices = c("newick", "phylo"))#
	if(is.null(tree$node.label)) stop("tree must have node labels")#
	if(!is.null(tree$edge.length)) tree$edge.length <- NULL#
	m <- match(nodenames, tree$node.label)#
	if(any(is.na(m))) stop("all nodenames must be in tree$node.label") # add a printed line saying which nodenames are not in tree$node.label#
	if(length(nodenames)!=length(nodeages)) stop("nodenames and nodeages musthave the same length")#
	if(!is.character(nodenames)) stop("nodenames must be a character vector")#
	if(!is.numeric(nodeages)) stop("nodeages must be a numeric vector")#
	ages_df <- data.frame(#
		a=nodenames,#
		b=nodeages#
	)#
	new.tree <- phylocomr::ph_bladj(ages = ages_df, phylo = tree)#
	attributes(new.tree) <- NULL#
	if(treeformat == "phylo") new.tree <- read.tree(text = new.tree)#
	# plot(new.tree)	#
	return(new.tree)#
}
x6 <- FixNegBrLen(x4, method="bladj")
plot(x6)
ape::axisPhylo()
input="(((((Pterois miles,Pterois volitans)Pteroinae)Teleostei)Chordata,Lymnaea))Metazoa;"
phytools::read.newick(input)
phytools::read.newick(text=input)
ape::plot(x)
geiger::plot(x)
library(ape)
library(geiger)
plot(x)
x <- phytools::read.newick(text=input)
plot(x)
plot(colapse.singles(x))
plot(collapse.singles(x))
x$edge
paleotree::createMrBayesConstraints
new1 <- ape::read.tree(text="((((Homo sapiens,Macaca mulatta)Catarrhini,((Melursus ursinus,Canis lupus pallipes)Caniformia,((Panthera pardus,Panthera tigris)Panthera,Herpestes fuscus))Carnivora)Boreoeutheria,Elephas maximus)Eutheria,Haliastur indus)Amniota;")
plot(new1)
new1 <- ape::read.tree(text= gsub(pattern = " ", replacement = "_", x = "((((Homo sapiens,Macaca mulatta)Catarrhini,((Melursus ursinus,Canis lupus pallipes)Caniformia,((Panthera pardus,Panthera tigris)Panthera,Herpestes fuscus))Carnivora)Boreoeutheria,Elephas maximus)Eutheria,Haliastur indus)Amniota;"))
plot(new1)
new1.cons <- paleotree::createMrBayesConstraints(new1)
new1.cons
new1.cons <- paleotree::createMrBayesConstraints(new1, partial=FALSE)
new1.cons
prop.part
paleotree::prop.part
paleotree:::prop.part
ape::prop.part(new1)
x <- ape::prop.part(new1)
x
ls(x)
str(x)
new2 <- ape::read.tree(text= gsub(pattern = " ", replacement = "_", x = "(((((Homo sapiens,Macaca mulatta)Catarrhini,((Melursus ursinus,Canis lupus pallipes)Caniformia,((Panthera pardus,Panthera tigris)Panthera,Herpestes fuscus))Carnivora)Boreoeutheria,Elephas maximus)Eutheria,Haliastur indus)Amniota,og);"))
plot(new2)
ape::prop.part(new2)
new2.cons <- paleotree::createMrBayesConstraints(new1, partial=FALSE)
new2.cons <- paleotree::createMrBayesConstraints(new2, partial=FALSE)
new2.cons
write(new2.cons, file= "~/Google Drive/datelife/mrbayes_tests/jungle8_constraints.txt")
library(datelife)#
library(ape)#
library(geiger)
ProcessPhy <- function(input, showstatus=TRUE){#
	if(class(input) == "phylo") {#
		input <- ape::write.tree(input)#
	}#
 	input <- gsub("\\+"," ",input)#
  	input <- stringr::str_trim(input, side = "both")#
  	phy.new.in <- NA#
   	# if(length(input) == 1) {#
    	# if(verbose)cat("\t", "Input is length 1.", "\n")#
	  	if(any(grepl("\\(.*\\).*;", input))) { #our test for newick#
	  		if(length(input)!=1) stop("Only one phylogeny can be processed at a time")#
	    	phy.new.in <- ape::collapse.singles(phytools::read.newick(text=gsub(" ", "_", input)))#
	    	if(showstatus) cat("\t", "Input is a phylogeny and it is correcly formatted.", "\n")#
	  	} else {#
	  		if(showstatus) cat("\t", "Input is not a phylogeny.", "\n")#
	  	}#
  	# }#
	return(phy.new.in)#
}
notnew <- "a;"
x <- ProcessPhy(notnew)
plot(x)
notnew <- "a,b;"
x <- ProcessPhy(notnew)
x
expect_warning(x <- ProcessPhy(notnew))
library(testthat)
expect_warning(x <- ProcessPhy(notnew))
expect_value(x <- ProcessPhy(notnew), NA)
expect_output(x <- ProcessPhy(notnew), NA)
expect_output(x <- ProcessPhy(notnew), "\tInput is not a phylogeny.\n")
expect_output(x <- ProcessPhy(notnew), "\tInput is not a phylogeny.")
expect_output(x <- ProcessPhy(notnew), "\t Input is not a phylogeny.")
expect_error(ProcessPhy(c(asd, lf)))
expect_output(x <- ProcessPhy(asd), "\t Input is a phylogeny and it is correcly formatted.")
asd <- "((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);"
lf <- "(((((Pterois miles,Pterois volitans)Pteroinae)Teleostei)Chordata,Lymnaea))Metazoa;"
expect_output(x <- ProcessPhy(asd), "\t Input is a phylogeny and it is correcly formatted.")
expect_output(x <- ProcessPhy(lf), "\t Input is a phylogeny and it is correcly formatted.")
expect_output(x <- ProcessPhy(notnew), "\t Input is not a phylogeny.")
expect_output(x <- ProcessPhy(notnew, showstatus=FALSE), "\t Input is not a phylogeny.")
ProcessPhy(notnew, showstatus=FALSE)
expect_output(x <- ProcessPhy(notnew, showstatus=FALSE), NA)
expect_output(x <- ProcessPhy("purr", showstatus=FALSE), NA)
expect_output(x <- ProcessPhy(c(asd,lf), showstatus=FALSE), NA)
expect_output(x <- ProcessPhy(c(asd,lf), showstatus=FALSE),"Only one phylogeny can be processed at a time.")
ProcessPhy(asd, lf)
ProcessPhy <- function(input, showstatus=TRUE){#
	if(class(input) == "phylo") {#
		input <- ape::write.tree(input)#
	}#
 	input <- gsub("\\+"," ",input)#
  	input <- stringr::str_trim(input, side = "both")#
  	phy.new.in <- NA#
   	# if(length(input) == 1) {#
    	# if(verbose)cat("\t", "Input is length 1.", "\n")#
	  	if(any(grepl("\\(.*\\).*;", input))) { #our test for newick#
	  		if(length(input)!=1) stop("Only one phylogeny can be processed at a time.")#
	    	phy.new.in <- ape::collapse.singles(phytools::read.newick(text=gsub(" ", "_", input)))#
	    	if(showstatus) {cat("\t", "Input is a phylogeny and it is correcly formatted.", "\n")}#
	  	} else {#
	  		if(showstatus) cat("\t", "Input is not a phylogeny.", "\n")#
	  	}#
  	# }#
	return(phy.new.in)#
}
ProcessPhy(asd, lf)
expect_output(x <- ProcessPhy(lf, showstatus=FALSE), "\t Input is a phylogeny and it is correcly formatted.")
expect_output(x <- ProcessPhy(lf, showstatus=FALSE), class(x)==phylo)
expect_output(x <- ProcessPhy(lf, showstatus=FALSE), class(x)=="phylo")
x <- ProcessPhy(lf, showstatus=FALSE)
x
expect_message(x <- ProcessPhy(asd), "\t Input is a phylogeny and it is correcly formatted.")
expect_condition(x <- ProcessPhy(lf, showstatus=FALSE), class="phylo")
expect_type(x <- ProcessPhy(lf, showstatus=FALSE), class="phylo")
expect_type(x <- ProcessPhy(lf, showstatus=FALSE), "phylo")
expect_S3_class(x <- ProcessPhy(lf, showstatus=FALSE), "phylo")
expect_S4_class(x <- ProcessPhy(lf, showstatus=FALSE), "phylo")
expect_class(x <- ProcessPhy(lf, showstatus=FALSE), "phylo")
expect_s3_class(x <- ProcessPhy(lf, showstatus=FALSE), "phylo")
expect_s4_class(x <- ProcessPhy(lf, showstatus=FALSE), "phylo")
expect_output(x <- ProcessPhy(notnew))
expect_output(x <- ProcessPhy(lf))
expect_output(x <- ProcessPhy(asd))
expect_output(x <- ProcessPhy(asd), "\t Input is a phylogeny and it is correcly formatted.")
class(NA)
expect_output(x <- ProcessPhy(notnew, showstatus=FALSE))
expect_type(x <- ProcessPhy("purrr", showstatus=FALSE), "logical")
expect_type(x <- ProcessPhy(notnew, showstatus=FALSE), "logical")
expect_output(x <- ProcessPhy(lf, showstatus=FALSE), NA)
asd <- ape::read.tree(text="((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);")
expect_error(ProcessPhy(c(asd, lf))) #trying to process two phylogenies will give an error
ProcessPhy <- function(input, showstatus=TRUE){#
	if(any(class(input)) == "phylo") {#
	  	if(length(input)!=1) stop("Only one phylogeny can be processed at a time.")#
		input <- ape::write.tree(input)#
	}#
 	input <- gsub("\\+"," ",input)#
  	input <- stringr::str_trim(input, side = "both")#
  	phy.new.in <- NA#
   	# if(length(input) == 1) {#
    	# if(verbose)cat("\t", "Input is length 1.", "\n")#
	  	if(any(grepl("\\(.*\\).*;", input))) { #our test for newick#
	  		if(length(input)!=1) stop("Only one phylogeny can be processed at a time.")#
	    	phy.new.in <- ape::collapse.singles(phytools::read.newick(text=gsub(" ", "_", input)))#
	    	if(showstatus) {cat("\t", "Input is a phylogeny and it is correcly formatted.", "\n")}#
	  	} else {#
	  		if(showstatus) {cat("\t", "Input is not a phylogeny.", "\n")}#
	  	}#
  	# }#
	return(phy.new.in)#
}
expect_error(ProcessPhy(c(asd, lf))) #trying to process two phylogenies will give an error
c(asd, lf)
class(c(asd, lf))
class(c(asd, asd))
class(c(lf, lf))
input <- class(c(asd, lf))
input
class(input) == "phylo" | class(input) == "list"
class(input) == "list"
class(input)
input
expect_error(ProcessPhy(c(asd, asd))) #trying to process two phylogenies will give an error
asd <- ape::read.tree(text="((Zea mays,Oryza sativa),((Arabidopsis thaliana,(Glycine max,Medicago sativa)),Solanum lycopersicum)Pentapetalae);")
expect_error(ProcessPhy(c(asd, asd))) #trying to process two phylogenies will give an error
asd
c(asd, asd)
ProcessPhy <- function(input, showstatus=TRUE){#
  	if(class(input) == "multiPhylo") stop("Only one phylogeny can be processed at a time.")#
	if(class(input) == "phylo") {#
		input <- ape::write.tree(input)#
	}#
 	input <- gsub("\\+"," ",input)#
  	input <- stringr::str_trim(input, side = "both")#
  	phy.new.in <- NA#
   	# if(length(input) == 1) {#
    	# if(verbose)cat("\t", "Input is length 1.", "\n")#
	  	if(any(grepl("\\(.*\\).*;", input))) { #our test for newick#
	  		if(length(input)!=1) stop("Only one phylogeny can be processed at a time.")#
	    	phy.new.in <- ape::collapse.singles(phytools::read.newick(text=gsub(" ", "_", input)))#
	    	if(showstatus) {cat("\t", "Input is a phylogeny and it is correcly formatted.", "\n")}#
	  	} else {#
	  		if(showstatus) {cat("\t", "Input is not a phylogeny.", "\n")}#
	  	}#
  	# }#
	return(phy.new.in)#
}
expect_error(ProcessPhy(c(asd, asd))) #trying to process two phylogenies will give an error
expect_error(ProcessPhy(c(notnew, notnew))) #trying to process two phylogenies will give an error
expect_error(ProcessPhy(c(notnew, notnew))) ==FALSE #trying to process two phylogenies will give an error
expect_s3_class(x <- ProcessPhy(asd, showstatus=FALSE), "phylo")
setwd("~/Desktop/datelife")#
devtools::load_all()#
library(ape)#
library(geiger)#
library(testthat)#
library(microbenchmark)
chronogram.matches <- rotl::studies_find_trees(property = "ot:branchLengthMode", value = "ot:time", verbose = TRUE, detailed = TRUE)#
	trees <- list()#
	authors <- list()#
	curators <- list()#
	studies <- list()#
	dois <- list()#
	tree.count <- 0#
	bad.ones <- c()
names(chronogram.matches)
dim(chronogram.matches)
for (study.index in sequence(dim(chronogram.matches)[1])) {#
		cat(study.index, "\t", i)#
		if(verbose) {#
			print(paste("Downloading tree(s) from study", study.index, "of",dim(chronogram.matches)[1]))#
		}#
		for(chrono.index in sequence((chronogram.matches$n_matched_trees[study.index]))) {#
			study.id <- chronogram.matches$study_ids[study.index]#
	#	new.tree <- get_study_tree(study_id=study.id, tree_id=tree.id, tip_label='ott_taxon_name')#
			new.tree <- NULL#
			tree.id <- strsplit(chronogram.matches$match_tree_ids[study.index], ", ")[[1]][chrono.index]#
			potential.bad <- paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep="")#
#
			if(!grepl("\\.\\.\\.", tree.id) & !is.na(tree.id)) { #to deal with ellipsis bug#
				#try(new.tree <- datelife:::get_study_tree_with_dups(study_id=study.id,tree_id=tree.id ))#
				#try(new.tree <- rotl::get_study_subtree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name", subtree_id="ingroup")) #only want ingroup, as it's the one that's been lovingly curated.#
				try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name")) #would like to dedup; don't use get_study_subtree, as right now it doesn't take tip_label args#
				#try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name"))#
				if(verbose) {#
					print(paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep=""))#
				}#
				if(!is.null(new.tree) & phylo_has_brlen(phy = new.tree)) {#
					new.tree <- clean_chronogram(new.tree)#
					if(phylo_has_brlen(phy = new.tree)) {#
						if(is_good_chronogram(new.tree)) {#
							new.tree$tip.label <- gsub('_', ' ', new.tree$tip.label)#
							if(verbose) {#
								print("has tree with branch lengths")#
							}#
							doi <- NULL#
							try(doi <- gsub('http://dx.doi.org/', '', attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI")))#
							authors <- append(authors, NA)#
							try(authors[length(authors)] <- list(paste(as.character(knitcitations::bib_metadata(doi)$author))))#
							curators <- append(curators, NA)#
							try(curators[length(curators)] <- list(rotl::get_study_meta(study.id)[["nexml"]][["^ot:curatorName"]]))#
							try(studies <- append(studies, study.id))#
							tree.count <- tree.count+1#
							try(dois <- append(dois, chronogram.matches$study_doi[study.index]))#
							trees[[tree.count]] <-new.tree#
							names(trees)[tree.count] <- rotl::get_publication(rotl::get_study_meta(study.id))[1]#
							print("was good tree")#
							potential.bad <- NULL#
						}#
					}#
				}#
			} else {#
				warning("Not all trees could be loaded from this study due to ellipsis bug, https://github.com/ropensci/rotl/issues/85")#
			}#
			if(!is.null(potential.bad)) {#
				bad.ones <- append(bad.ones, potential.bad)#
			}#
			#save(list=ls(), file="opentree_chronograms.RData")#
		}#
	}
for (study.index in sequence(dim(chronogram.matches)[1])) {#
		cat("study.index =", "\t", study.index)#
		if(verbose) {#
			print(paste("Downloading tree(s) from study", study.index, "of",dim(chronogram.matches)[1]))#
		}#
		for(chrono.index in sequence((chronogram.matches$n_matched_trees[study.index]))) {#
			study.id <- chronogram.matches$study_ids[study.index]#
	#	new.tree <- get_study_tree(study_id=study.id, tree_id=tree.id, tip_label='ott_taxon_name')#
			new.tree <- NULL#
			tree.id <- strsplit(chronogram.matches$match_tree_ids[study.index], ", ")[[1]][chrono.index]#
			potential.bad <- paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep="")#
#
			if(!grepl("\\.\\.\\.", tree.id) & !is.na(tree.id)) { #to deal with ellipsis bug#
				#try(new.tree <- datelife:::get_study_tree_with_dups(study_id=study.id,tree_id=tree.id ))#
				#try(new.tree <- rotl::get_study_subtree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name", subtree_id="ingroup")) #only want ingroup, as it's the one that's been lovingly curated.#
				try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name")) #would like to dedup; don't use get_study_subtree, as right now it doesn't take tip_label args#
				#try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name"))#
				if(verbose) {#
					print(paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep=""))#
				}#
				if(!is.null(new.tree) & phylo_has_brlen(phy = new.tree)) {#
					new.tree <- clean_chronogram(new.tree)#
					if(phylo_has_brlen(phy = new.tree)) {#
						if(is_good_chronogram(new.tree)) {#
							new.tree$tip.label <- gsub('_', ' ', new.tree$tip.label)#
							if(verbose) {#
								print("has tree with branch lengths")#
							}#
							doi <- NULL#
							try(doi <- gsub('http://dx.doi.org/', '', attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI")))#
							authors <- append(authors, NA)#
							try(authors[length(authors)] <- list(paste(as.character(knitcitations::bib_metadata(doi)$author))))#
							curators <- append(curators, NA)#
							try(curators[length(curators)] <- list(rotl::get_study_meta(study.id)[["nexml"]][["^ot:curatorName"]]))#
							try(studies <- append(studies, study.id))#
							tree.count <- tree.count+1#
							try(dois <- append(dois, chronogram.matches$study_doi[study.index]))#
							trees[[tree.count]] <-new.tree#
							names(trees)[tree.count] <- rotl::get_publication(rotl::get_study_meta(study.id))[1]#
							print("was good tree")#
							potential.bad <- NULL#
						}#
					}#
				}#
			} else {#
				warning("Not all trees could be loaded from this study due to ellipsis bug, https://github.com/ropensci/rotl/issues/85")#
			}#
			if(!is.null(potential.bad)) {#
				bad.ones <- append(bad.ones, potential.bad)#
			}#
			#save(list=ls(), file="opentree_chronograms.RData")#
		}#
	}
verbose = FALSE
for (study.index in sequence(dim(chronogram.matches)[1])) {#
		cat("study.index =", "\t", study.index, "\n")#
		if(verbose) {#
			print(paste("Downloading tree(s) from study", study.index, "of",dim(chronogram.matches)[1]))#
		}#
		for(chrono.index in sequence((chronogram.matches$n_matched_trees[study.index]))) {#
			study.id <- chronogram.matches$study_ids[study.index]#
	#	new.tree <- get_study_tree(study_id=study.id, tree_id=tree.id, tip_label='ott_taxon_name')#
			new.tree <- NULL#
			tree.id <- strsplit(chronogram.matches$match_tree_ids[study.index], ", ")[[1]][chrono.index]#
			potential.bad <- paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep="")#
#
			if(!grepl("\\.\\.\\.", tree.id) & !is.na(tree.id)) { #to deal with ellipsis bug#
				#try(new.tree <- datelife:::get_study_tree_with_dups(study_id=study.id,tree_id=tree.id ))#
				#try(new.tree <- rotl::get_study_subtree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name", subtree_id="ingroup")) #only want ingroup, as it's the one that's been lovingly curated.#
				try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name")) #would like to dedup; don't use get_study_subtree, as right now it doesn't take tip_label args#
				#try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name"))#
				if(verbose) {#
					print(paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep=""))#
				}#
				if(!is.null(new.tree) & phylo_has_brlen(phy = new.tree)) {#
					new.tree <- clean_chronogram(new.tree)#
					if(phylo_has_brlen(phy = new.tree)) {#
						if(is_good_chronogram(new.tree)) {#
							new.tree$tip.label <- gsub('_', ' ', new.tree$tip.label)#
							if(verbose) {#
								print("has tree with branch lengths")#
							}#
							doi <- NULL#
							try(doi <- gsub('http://dx.doi.org/', '', attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI")))#
							authors <- append(authors, NA)#
							try(authors[length(authors)] <- list(paste(as.character(knitcitations::bib_metadata(doi)$author))))#
							curators <- append(curators, NA)#
							try(curators[length(curators)] <- list(rotl::get_study_meta(study.id)[["nexml"]][["^ot:curatorName"]]))#
							try(studies <- append(studies, study.id))#
							tree.count <- tree.count+1#
							try(dois <- append(dois, chronogram.matches$study_doi[study.index]))#
							trees[[tree.count]] <-new.tree#
							names(trees)[tree.count] <- rotl::get_publication(rotl::get_study_meta(study.id))[1]#
							print("was good tree")#
							potential.bad <- NULL#
						}#
					}#
				}#
			} else {#
				warning("Not all trees could be loaded from this study due to ellipsis bug, https://github.com/ropensci/rotl/issues/85")#
			}#
			if(!is.null(potential.bad)) {#
				bad.ones <- append(bad.ones, potential.bad)#
			}#
			#save(list=ls(), file="opentree_chronograms.RData")#
		}#
	}
print(bad.ones)
warnings()
authors[[148]]
length(authors)
study.index <- 148
chronogram.matches$n_matched_trees[study.index]
study.id <- chronogram.matches$study_ids[study.index]
study.id
new.tree <- NULL#
			tree.id <- strsplit(chronogram.matches$match_tree_ids[study.index], ", ")[[1]][chrono.index]#
			potential.bad <- paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep="")
!grepl("\\.\\.\\.", tree.id) & !is.na(tree.id)
try(new.tree <- rotl::get_study_tree(study_id=study.id,tree_id=tree.id, tip_label="ott_taxon_name")) #would like to dedup; don't use get_study_subtree, as right now it doesn't take tip_label args
print(paste("tree_id='", tree.id, "', study_id='", study.id, "'", sep=""))
!is.null(new.tree) & phylo_has_brlen(phy = new.tree)
new.tree <- clean_chronogram(new.tree)
new.tree
phylo_has_brlen(phy = new.tree)
is_good_chronogram(new.tree)
new.tree$tip.label <- gsub('_', ' ', new.tree$tip.label)
print("has tree with branch lengths")
doi <- NULL
try(doi <- gsub('http://dx.doi.org/', '', attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI")))
authors <- append(authors, NA)
authors
try(authors[length(authors)] <- list(paste(as.character(knitcitations::bib_metadata(doi)$author))))
length(authors)
doi
doi <- gsub('http://dx.doi.org/', '', attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI"))
doi
study.id
rotl::get_publication(rotl::get_study_meta(study.id))
attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI")
rotl::get_study_meta(study.id)
rotl::get_study_meta(study.id)[["nexml"]][["^ot:curatorName"]])
list(rotl::get_study_meta(study.id)[["nexml"]][["^ot:curatorName"]])
doi
rotl::get_publication(rotl::get_study_meta(study.id))
study.index <- 149
study.id <- chronogram.matches$study_ids[study.index]
study.id
doi <- NULL
try(doi <- gsub('http://dx.doi.org/', '', attr(rotl::get_publication(rotl::get_study_meta(study.id)), "DOI")))
doi
rotl::get_publication(rotl::get_study_meta(study.id))
study.index <- 148
try(studies <- append(studies, study.id))
append(studies, study.id)
study.id <- chronogram.matches$study_ids[study.index]
study.id
chronogram.matches$study_doi[study.index]
dois
save(dois, file = "~/Google Drive/datelife/datelife_tests_2018.02.21.R_opentree_chronograms_study_dois.RData")
authors
authors[[148]]
for(i in sequence(length(authors))){#
		cat("authors i = ", i, "\n")#
		print(authors[[i]])#
		if(!any(is.na(authors[[i]])) | length(authors[[i]]) > 0){#
			Encoding(authors[[i]]) <- "latin1"#
			authors[[i]] <- iconv(authors[[i]], "latin1", "UTF-8")#
		}#
		if(!any(is.na(curators[[i]])) | length(curators[[i]]) > 0){#
			Encoding(curators[[i]]) <- "latin1"#
			curators[[i]] <- iconv(curators[[i]], "latin1", "UTF-8")#
		}#
	}
i
authors[[i]]
Encoding(authors[[i]])
Encoding(authors[[i]]) <- "latin1"
authors[[i]] <- iconv(authors[[i]], "latin1", "UTF-8")
curators[[i]]
for(i in sequence(length(authors))){#
		cat("authors i = ", i, "\n")#
		print(authors[[i]])#
		if(!any(is.na(authors[[i]])) | length(authors[[i]]) > 0){#
			Encoding(authors[[i]]) <- "latin1"#
			authors[[i]] <- iconv(authors[[i]], "latin1", "UTF-8")#
		}#
		for (j in sequence(length(curators))){#
			if(!any(is.na(curators[[i]])) | length(curators[[i]]) > 0){#
				Encoding(curators[[i]]) <- "latin1"#
				curators[[i]] <- iconv(curators[[i]], "latin1", "UTF-8")#
			}			#
		}#
	}
for(i in sequence(length(authors))){#
		cat("authors i = ", i, "\n")#
		print(authors[[i]])#
		if(!any(is.na(authors[[i]])) | length(authors[[i]]) > 0){#
			Encoding(authors[[i]]) <- "latin1"#
			authors[[i]] <- iconv(authors[[i]], "latin1", "UTF-8")#
		}#
		for (j in sequence(length(curators[[i]]))){#
			if(!any(is.na(curators[[i]][[j]])) | length(curators[[i]][[j]]) > 0){#
				Encoding(curators[[i]][[j]]) <- "latin1"#
				curators[[i]][[j]] <- iconv(curators[[i]][[j]], "latin1", "UTF-8")#
			}			#
		}#
	}
authors[[172]]
i <- 172
print(authors[[i]])
i <- 169
Encoding(authors[[i]])
i <- 172
!any(is.na(authors[[i]]))
length(authors[[i]]) > 0
if(!any(is.na(authors[[i]])) | length(authors[[i]]) > 0){#
			Encoding(authors[[i]]) <- "latin1"#
			authors[[i]] <- iconv(authors[[i]], "latin1", "UTF-8")#
		}
!any(is.na(c()))
xx <- character()
xx
!ani(is.na(xx))
!any(is.na(xx))
for(i in sequence(length(authors))){#
		cat("authors i = ", i, "\n")#
		print(authors[[i]])#
		if(!any(is.na(authors[[i]])) & length(authors[[i]]) > 0){#
			Encoding(authors[[i]]) <- "latin1"#
			authors[[i]] <- iconv(authors[[i]], "latin1", "UTF-8")#
		}#
		for (j in sequence(length(curators[[i]]))){#
			if(!any(is.na(curators[[i]][[j]])) & length(curators[[i]][[j]]) > 0){#
				Encoding(curators[[i]][[j]]) <- "latin1"#
				curators[[i]][[j]] <- iconv(curators[[i]][[j]], "latin1", "UTF-8")#
			}			#
		}#
	}
i <- 203
curators[[i]]
load("/Users/luna/Desktop/datelife/data/opentree_chronograms.RData")
opentree_chronograms
make_contributor_cache(outputfile = 'contributorcache.RData')
